// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Hasher {

    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256[10] c = [
        0,
        16729685603937456913125195466104274273722599903222208679278607187345483161700,
        61176161174061927029854771852254014634237258579987163066755408023802674807882,
        84973701653090265572993326388253545491142258376912995084719734401667825605678,
        26013738218527197848992914378807408968112874484685745004409134820598712888136,
        72303167244498365569164283593093618388765957401995476850579802848976072347831,
        112828019091853157885887914205417244473828091214855356895156652146037600146516,
        75551628256363290728184220392915707565055310104917701384304383490660096722396,
        99530042614414796021476440819952189161802552016631820151331330093783365349555,
        48038538177942375191643859924678997017789662096094142506590288137000238340141
    ];


    function generateHash(uint256 x, uint256 k) public view returns(bytes32) {

        uint256 lastOutputs;
        uint256 base;
        uint256 base2;
        uint256 base4;

        lastOutputs = x;

        // Constraints.
        for (uint256 i = 0; i < 10; i++){
            base = addmod(lastOutputs, c[i], p);
            base = addmod(base, k, p);
            base2 = mulmod(base, base, p);
            base4 = mulmod(base2, base2, p);

            lastOutputs = mulmod(base, base4, p);
        }

        uint256 h = addmod(lastOutputs, k, p);

        return bytes32(h); 
    }
}